import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { logger } from 'hono/logger'
import { 
  generateRoomId, 
  generateHostToken, 
  validateRoomId, 
  validateMessage,
  sanitizeHtml,
  RateLimiter,
  SecurityErrorCode,
  CONFIG,
  RuntimeDetector 
} from './utils/room'

// ğŸ”’ å‹å®‰å…¨ãª WebSocket ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
type UpgradeWebSocketFn = (handler: (c: any) => any) => any

let upgradeWebSocket: UpgradeWebSocketFn | undefined
if (RuntimeDetector.isCloudflareWorkers()) {
  try {
    upgradeWebSocket = require('hono/cloudflare-workers').upgradeWebSocket as UpgradeWebSocketFn
  } catch (error) {
    console.error('Failed to load Cloudflare Workers WebSocket module:', error)
  }
}

// Buné–‹ç™ºç’°å¢ƒã¨Cloudflare Workersä¸¡å¯¾å¿œã®å‹å®šç¾©
type Bindings = {
  ENVIRONMENT: string
}

// WebSocketç”¨ã®å‹å®šç¾©
interface ClientMessage {
  type: 'ping' | 'join_room' | 'leave_room' | 'send_message'
  timestamp: number
  data?: any
}

interface ServerMessage {
  type: 'pong' | 'room_joined' | 'room_left' | 'message' | 'error' | 'user_joined' | 'user_left'
  timestamp: number
  data?: any
}

interface UserInfo {
  id: string
  username?: string
  joinedAt: number
}

// ğŸ”’ æ§‹é€ åŒ–ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹
interface ErrorResponse {
  type: 'error'
  code: SecurityErrorCode
  message: string
  timestamp: number
  context?: Record<string, any>
}

function createErrorResponse(code: SecurityErrorCode, message: string, context?: any): ErrorResponse {
  return {
    type: 'error',
    code,
    message,
    timestamp: Date.now(),
    context
  }
}

// ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªãƒ«ãƒ¼ãƒ ç®¡ç†ï¼ˆãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä¸ä½¿ç”¨ï¼‰
// ğŸš¨ é‡è¦ãªåˆ¶é™: Cloudflare Workersã¯ç„¡çŠ¶æ…‹ã®ãŸã‚ã€ç•°ãªã‚‹WebSocketæ¥ç¶šé–“ã§Mapã¯å…±æœ‰ã•ã‚Œãªã„
// å®Ÿéš›ã®ãƒãƒ«ãƒãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒãƒ£ãƒƒãƒˆã«ã¯ Durable Objects ãŒå¿…è¦
// ç¾åœ¨ã®å®Ÿè£…ã¯å˜ä¸€æ¥ç¶šã® ping/pongã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚¨ã‚³ãƒ¼ã®ã¿å¯¾å¿œ
const roomSessions = new Map<string, Set<WebSocket>>()
const roomUsers = new Map<string, Map<WebSocket, UserInfo>>()
const roomCreatedAt = new Map<string, number>()

// WebSocket ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
function sendMessage(ws: WebSocket, message: ServerMessage) {
  if (ws.readyState === WebSocket.READY_STATE_OPEN) {
    ws.send(JSON.stringify(message))
  }
}

function broadcastToRoom(roomId: string, message: ServerMessage, excludeWs?: WebSocket) {
  const sessions = roomSessions.get(roomId)
  if (sessions) {
    sessions.forEach(ws => {
      if (ws !== excludeWs) {
        sendMessage(ws, message)
      }
    })
  }
}

function joinRoom(roomId: string, ws: WebSocket, userInfo: UserInfo) {
  // ãƒ«ãƒ¼ãƒ ä½œæˆï¼ˆå­˜åœ¨ã—ãªã„å ´åˆï¼‰
  if (!roomSessions.has(roomId)) {
    roomSessions.set(roomId, new Set())
    roomUsers.set(roomId, new Map())
    roomCreatedAt.set(roomId, Date.now())
  }

  const sessions = roomSessions.get(roomId)!
  const users = roomUsers.get(roomId)!
  
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚’ãƒ«ãƒ¼ãƒ ã«è¿½åŠ 
  sessions.add(ws)
  users.set(ws, userInfo)

  // æ—¢å­˜ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å‚åŠ é€šçŸ¥
  broadcastToRoom(roomId, {
    type: 'user_joined',
    timestamp: Date.now(),
    data: { userId: userInfo.id, username: userInfo.username }
  }, ws)

  // å‚åŠ è€…ã«æˆåŠŸé€šçŸ¥
  sendMessage(ws, {
    type: 'room_joined',
    timestamp: Date.now(),
    data: { 
      roomId,
      participantCount: sessions.size,
      yourUserId: userInfo.id 
    }
  })
}

function leaveRoom(roomId: string, ws: WebSocket) {
  const sessions = roomSessions.get(roomId)
  const users = roomUsers.get(roomId)
  
  if (sessions && users) {
    const userInfo = users.get(ws)
    
    sessions.delete(ws)
    users.delete(ws)

    // ä»–ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€€å‡ºé€šçŸ¥
    if (userInfo) {
      broadcastToRoom(roomId, {
        type: 'user_left',
        timestamp: Date.now(),
        data: { userId: userInfo.id, username: userInfo.username }
      })
    }

    // ãƒ«ãƒ¼ãƒ ãŒç©ºã«ãªã£ãŸã‚‰ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    if (sessions.size === 0) {
      roomSessions.delete(roomId)
      roomUsers.delete(roomId)
      roomCreatedAt.delete(roomId)
    }
  }
}

const app = new Hono<{ Bindings: Bindings }>()

// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®šãƒŸãƒ‰ãƒ«ã‚¦ã‚§ã‚¢
app.use('*', async (c, next) => {
  const start = performance.now()
  await next()
  const end = performance.now()
  c.header('X-Response-Time', `${end - start}ms`)
})

app.use('*', logger())
app.use('*', cors({
  origin: ['chrome-extension://*', 'http://localhost:*'],
  allowHeaders: ['Content-Type', 'Authorization'],
  allowMethods: ['GET', 'POST', 'OPTIONS'],
}))

// ãƒ«ãƒ¼ãƒˆã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
app.get('/', (c) => {
  return c.json({
    service: 'Tiny Watch Party WebSocket Server',
    runtime: RuntimeDetector.current,
    environment: c.env?.ENVIRONMENT || 'development',
    timestamp: new Date().toISOString(),
    endpoints: {
      health: '/health',
      status: '/status',
      perf: '/perf',
      roomCreate: '/api/rooms/create',
      roomValidate: '/api/rooms/{roomId}/validate',
      webSocket: '/ws/{roomId}'
    },
    performance: {
      note: RuntimeDetector.getPerformanceNote()
    }
  })
})

// ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯ with ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æƒ…å ±
app.get('/health', (c) => {
  return c.json({
    status: 'healthy',
    service: 'tiny-watch-party-worker',
    runtime: RuntimeDetector.current,
    environment: c.env?.ENVIRONMENT || 'development',
    timestamp: new Date().toISOString(),
    uptime: Date.now(),
    version: '1.0.0',
    features: {
      webSocket: RuntimeDetector.isCloudflareWorkers() ? 'ğŸš§ (Stateless - Single user only)' : 'ğŸš§ (CF Workers only)',
      honoFramework: 'âœ…',
      typeScript: 'âœ…',
      cors: 'âœ…',
      performance: 'âœ…',
      roomManagement: 'âœ…'
    },
    limitations: {
      webSocket: 'Current implementation supports single-user connections only. Multi-user chat requires Durable Objects.',
      state: 'Stateless Workers - no shared memory between WebSocket connections'
    }
  })
})

// ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è©³ç´°ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
app.get('/status', (c) => {
  const url = new URL(c.req.url)
  
  return c.json({
    status: 'operational',
    timestamp: new Date().toISOString(),
    runtime: RuntimeDetector.current,
    environment: c.env?.ENVIRONMENT || 'development',
    request: {
      method: c.req.method,
      url: url.toString(),
      userAgent: c.req.header('User-Agent') || 'unknown'
    },
    worker: {
      region: (c.req as any).cf?.colo || 'local',
      country: (c.req as any).cf?.country || 'local',
      ip: c.req.header('CF-Connecting-IP') || c.req.header('X-Forwarded-For') || 'localhost'
    },
    performance: {
      runtime: RuntimeDetector.current,
      note: RuntimeDetector.getPerformanceNote()
    }
  })
})

// ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
app.get('/perf', async (c) => {
  const start = performance.now()
  
  // è»½é‡ãªå‡¦ç†ã§ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
  const data = Array.from({ length: 1000 }, (_, i) => ({ id: i, value: Math.random() }))
  const processed = data.filter(item => item.value > 0.5).map(item => ({ ...item, processed: true }))
  
  const end = performance.now()
  
  return c.json({
    runtime: RuntimeDetector.current,
    processingTime: `${end - start}ms`,
    dataProcessed: {
      total: data.length,
      filtered: processed.length
    },
    timestamp: new Date().toISOString()
  })
})

// ãƒ«ãƒ¼ãƒ ä½œæˆAPI
app.post('/api/rooms/create', async (c) => {
  const roomId = generateRoomId()
  const hostToken = generateHostToken()
  const createdAt = new Date()
  const expiresAt = new Date(createdAt.getTime() + 3 * 60 * 60 * 1000) // 3æ™‚é–“å¾Œ
  
  // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ˜ãƒƒãƒ€ãƒ¼è¨­å®š
  c.header('X-Room-Id', roomId)
  c.header('X-Host-Token', hostToken)
  
  const host = c.req.header('host') || 'localhost:3000'
  const protocol = host.includes('localhost') ? 'ws://' : 'wss://'
  
  return c.json({
    roomId,
    createdAt: createdAt.toISOString(),
    expiresAt: expiresAt.toISOString(),
    hostToken,
    websocketUrl: `${protocol}${host}/ws/${roomId}`,
    shareUrl: `https://tiny-watch-party.example.com/join/${roomId}`,
    management: {
      validateUrl: `/api/rooms/${roomId}/validate`,
      maxParticipants: 10,
      autoExpire: true
    }
  }, 201)
})

// ãƒ«ãƒ¼ãƒ æƒ…å ±å–å¾—ãƒ»ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
app.get('/api/rooms/:roomId/validate', (c) => {
  const roomId = c.req.param('roomId')
  const isValid = validateRoomId(roomId)
  
  return c.json({
    roomId,
    valid: isValid,
    message: isValid ? 'Valid room ID format' : 'Invalid room ID format',
    format: 'XXXX-YYYY-ZZZZ (12 characters, A-Z and 0-9)',
    example: 'A3F2-8K9L-4MN7'
  })
})

// ãƒ«ãƒ¼ãƒ ä¸€è¦§ï¼ˆãƒ‡ãƒ¢ç”¨ï¼‰
app.get('/api/rooms', (c) => {
  // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‹ã‚‰å–å¾—
  const demoRooms = [
    {
      roomId: generateRoomId(),
      status: 'active',
      participants: Math.floor(Math.random() * 5) + 1,
      createdAt: new Date(Date.now() - Math.random() * 3600000).toISOString()
    },
    {
      roomId: generateRoomId(),
      status: 'active', 
      participants: Math.floor(Math.random() * 3) + 1,
      createdAt: new Date(Date.now() - Math.random() * 3600000).toISOString()
    }
  ]
  
  return c.json({
    rooms: demoRooms,
    total: demoRooms.length,
    note: 'This is demo data. Real implementation would use database.'
  })
})

// WebSocket ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆï¼ˆç’°å¢ƒã«å¿œã˜ã¦åˆ†å²ï¼‰
if (RuntimeDetector.isCloudflareWorkers() && upgradeWebSocket) {
  // Cloudflare Workersç’°å¢ƒ
  app.get('/ws/:roomId', upgradeWebSocket((c) => {
    const roomId = c.req.param('roomId')
    
    // ğŸ”’ æ¥ç¶šãƒ¬ãƒ¼ãƒˆåˆ¶é™
    const clientIp = c.req.header('CF-Connecting-IP') || c.req.header('X-Forwarded-For') || 'unknown'
    if (RateLimiter.isRateLimited(`conn-${clientIp}`, CONFIG.SECURITY.RATE_LIMIT.CONNECTIONS_PER_MINUTE, CONFIG.SECURITY.RATE_LIMIT.WINDOW_MS)) {
      return {
        onOpen(event, ws) {
          sendMessage(ws, createErrorResponse(SecurityErrorCode.RATE_LIMITED, 'Too many connection attempts'))
          ws.close(1008, 'Rate limited')
        }
      }
    }
    
    // ãƒ«ãƒ¼ãƒ IDæ¤œè¨¼
    if (!validateRoomId(roomId)) {
      return {
        onOpen(event, ws) {
          sendMessage(ws, createErrorResponse(SecurityErrorCode.INVALID_ROOM_ID, 'Invalid room ID format'))
          ws.close(1000, 'Invalid room ID')
        }
      }
    }

    return {
      onMessage(event, ws) {
        try {
          // ğŸ”’ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚µã‚¤ã‚ºåˆ¶é™
          if (typeof event.data === 'string' && event.data.length > 5000) {
            sendMessage(ws, createErrorResponse(SecurityErrorCode.MESSAGE_TOO_LARGE, 'Message too large'))
            return
          }

          const message: ClientMessage = JSON.parse(event.data as string)
          
          // ğŸ”’ å…¥åŠ›æ¤œè¨¼
          const validation = validateMessage(message)
          if (!validation.valid) {
            sendMessage(ws, createErrorResponse(SecurityErrorCode.INVALID_MESSAGE, validation.error || 'Invalid message'))
            return
          }

          // ğŸ”’ ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯
          const clientIp = (event as any).request?.headers?.get('CF-Connecting-IP') || 'unknown'
          if (RateLimiter.isRateLimited(`msg-${clientIp}`, CONFIG.SECURITY.RATE_LIMIT.MESSAGES_PER_MINUTE, CONFIG.SECURITY.RATE_LIMIT.WINDOW_MS)) {
            sendMessage(ws, createErrorResponse(SecurityErrorCode.RATE_LIMITED, 'Too many messages, please slow down'))
            return
          }
          
          switch (message.type) {
            case 'ping':
              sendMessage(ws, {
                type: 'pong',
                timestamp: Date.now()
              })
              break

            case 'join_room':
              if (message.data?.userId) {
                // ğŸ”’ ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
                const sanitizedUserId = sanitizeHtml(message.data.userId)
                const sanitizedUsername = message.data.username ? sanitizeHtml(message.data.username) : `User-${sanitizedUserId.slice(0, 6)}`
                
                const userInfo: UserInfo = {
                  id: sanitizedUserId,
                  username: sanitizedUsername,
                  joinedAt: Date.now()
                }
                joinRoom(roomId, ws, userInfo)
              } else {
                sendMessage(ws, createErrorResponse(SecurityErrorCode.INVALID_MESSAGE, 'userId is required for join_room'))
              }
              break

            case 'send_message':
              if (message.data?.message && message.data?.userId) {
                // ğŸ”’ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã®ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
                const sanitizedMessage = sanitizeHtml(message.data.message)
                const sanitizedUsername = message.data.username ? sanitizeHtml(message.data.username) : 'Anonymous'
                const sanitizedUserId = sanitizeHtml(message.data.userId)
                
                // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’åŒã˜ãƒ«ãƒ¼ãƒ ã®å…¨å‚åŠ è€…ã«ãƒ–ãƒ­ãƒ¼ãƒ‰ã‚­ãƒ£ã‚¹ãƒˆ
                broadcastToRoom(roomId, {
                  type: 'message',
                  timestamp: Date.now(),
                  data: {
                    message: sanitizedMessage,
                    userId: sanitizedUserId,
                    username: sanitizedUsername
                  }
                })
              } else {
                sendMessage(ws, createErrorResponse(SecurityErrorCode.INVALID_MESSAGE, 'message and userId are required'))
              }
              break

            case 'leave_room':
              leaveRoom(roomId, ws)
              sendMessage(ws, {
                type: 'room_left',
                timestamp: Date.now(),
                data: { roomId }
              })
              break

            default:
              sendMessage(ws, createErrorResponse(SecurityErrorCode.INVALID_MESSAGE, `Unknown message type: ${message.type}`))
          }
        } catch (error) {
          console.error('WebSocket message error:', error)
          if (error instanceof SyntaxError) {
            sendMessage(ws, createErrorResponse(SecurityErrorCode.INVALID_MESSAGE, 'Invalid JSON format'))
          } else {
            sendMessage(ws, createErrorResponse(SecurityErrorCode.INVALID_MESSAGE, 'Message processing error'))
          }
        }
      },

      onClose(event, ws) {
        console.log(`WebSocket connection closed for room ${roomId}: ${event.code} ${event.reason}`)
        leaveRoom(roomId, ws)
      },

      onError(event, ws) {
        console.error(`WebSocket error in room ${roomId}:`, event)
        leaveRoom(roomId, ws)
      }
    }
  }))
} else {
  // Buné–‹ç™ºç’°å¢ƒã§ã¯ä»£æ›¿ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
  app.get('/ws/:roomId', (c) => {
    return c.json({
      error: 'WebSocket not supported in development mode',
      message: 'WebSocket functionality is only available in Cloudflare Workers environment',
      roomId: c.req.param('roomId'),
      alternatives: {
        production: 'Deploy to Cloudflare Workers to test WebSocket functionality',
        testing: 'Use curl/fetch to test HTTP APIs instead'
      }
    }, 501)
  })
}

// 404ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
app.notFound((c) => {
  return c.json({
    error: 'Not Found',
    message: 'The requested endpoint does not exist.',
    timestamp: new Date().toISOString(),
    availableEndpoints: ['/', '/health', '/status', '/perf', 'POST /api/rooms/create', '/api/rooms', '/api/rooms/{roomId}/validate']
  }, 404)
})

// ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
app.onError((err, c) => {
  console.error('Error:', err)
  return c.json({
    error: 'Internal Server Error',
    message: err.message,
    timestamp: new Date().toISOString()
  }, 500)
})

// Buné–‹ç™ºã‚µãƒ¼ãƒãƒ¼ç”¨ã¨Cloudflare Workersç”¨ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ
export default {
  port: 3000,
  fetch: app.fetch,
}